'''
Лабораторная работа №2 
Написать программу, которая читая файл, распознает, преобразует и выводит на экран числа по определенному правилу.
Числа распознаются по законам грамматики русского языка. Преобразование делать по возможности через словарь.
Для упрощения под выводом числа прописью подразумевается последовательный вывод всех цифр числа.
Распознование делать через регулярные выражения. В вариантах, где есть параметр К, К заменяется на любое число.

Вариант 24. 
Шеснадцатиричные числа, не превышающие 102410 расположенные в порядке убывания. Для каждой такой последовательности максимальное число вывести прописью.
'''
import re

with open('tests.txt') as file:
    text = file.read()

num = {0: '', 1: 'один', 2: 'два', 3: 'три', 4: 'четыре', 5: 'пять',
       6: 'шесть', 7: 'семь', 8: 'восемь', 9: 'девять'}
doz = {0: '', 1: 'десять', 2: 'двадцать', 3: 'тридцать', 4: 'сорок',
       5: 'пятьдесят', 6: 'шестьдесят', 7: 'семьдесят',
       8: 'восемьдесят', 9: 'девяносто'}
doz1 = {0: '', 10: 'десять', 11: 'одиннадцать', 12: 'двенадцать', 13: 'тринадцать',
        14: 'четырнадцать', 15: 'пятнадцать', 16: 'шестнадцать',
        17: 'семнадцать', 18: 'восемнадцать', 19: 'девятнадцать'}
hun = {0: '', 1: 'сто', 2: 'двести', 3: 'триста', 4: 'четыреста',
       5: 'пятьсот', 6: 'шестьсот', 7: 'семьсот', 8: 'восемьсот',
       9: 'девятьсот'}
tho = {1: 'одна тысяча', 2: 'две тысячи', 3: 'три тысячи', 4: 'четыре тысячи'}
pattern = r'(?:(?<=\b)(?:(?:400)|(?:0*[1-3][\dA-F]{2})|(?:0*[\dA-F]{2}))\s*(?=\b)){2,}'
match_strings = re.findall(pattern, text)
res = []  # Результирующий список убывающих подпоследовательностей
for sequence in match_strings:
    # Проход по всем найденым совпадениям в тексте
    sequence_lst = sequence.split()  # Разбиваем на слова
    i = 0
    while i < len(sequence_lst) - 1:  # Проверяем каждое число с последующими
        desc_sequence = [int(sequence_lst[i], 16)]  # Заполняем первый элемент проверяемой последовательности
        for j in range(i + 1, len(sequence_lst)): 
            i = j - 1  
            if int(sequence_lst[j - 1], 16) > int(sequence_lst[j],  16):  # Если следующий элемент меньше предыдущего, то добавлем его в desc_sequence
                desc_sequence.append(int(sequence_lst[j], 16))
                continue
            else: 
                break
        if len(desc_sequence) - 1:  # Если длина полученной убывающей подпоследовательности >1, то добавляем в итоговый результат
            res.append(desc_sequence)
        i += 1
if res:
    for item in res:
        h = str(max(item))
        e = len(h)
        for i in range(len(h)):
            if int(h[i]) != 0:
                if e == 4:
                    print(tho[int(h[i])], end=' ')
                    e -= 1
                elif e == 3:
                    print(hun[int(h[i])], end=' ')
                    e -= 1
                elif e == 2:
                    if int(h[-1]) != 0 and int(h[i]) == 1:
                        print(doz1[int(h[i:])], end=' ')
                        e -= 2
                    else:
                        print(doz[int(h[i])], end=' ')
                        e -= 1
                elif e == 1:
                    print(num[int(h[i])], end=' ')
                    e -= 1
            else:
                e -= 1
        print()
else:
    print('Подходящих под условие последовательностей не найдено')



